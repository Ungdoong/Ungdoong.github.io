## 서론

 피들러의 HTTP 통신의 복호화를 위해 인증서를 등록하는 기능을 사용하다가 인증서의 원리가 무엇인지 깊게 파고들고 싶어졌습니다.ㅎ_ㅎ 그래서 이번 포스트에서는 HTTP와 SSL 인증서에 대해 다뤄보도록 하겠습니다. 주로 같은 업무를 하는 동료가 추천해준 유튜브 영상과 생활코딩의 인증서관련 내용을 보고 학습하였습니다 ^__^



## HTTPS를 쓰는 이유는 뭔가요?

1. 나의 정보가 목적지로 가는 동안 다른사람이 내용을 확인하지 못하게 하고싶어!
2. 내가 접속한 사이트가 믿을 만한 곳인지 알고싶어!

## HTTPS란?

HTTP에서 Secure의 S가 붙은 것으로 기존 HTTP 통신에서 보안이 더 강화된 프로토콜입니다. S는 정확히 SSL(Secure Socket Layer)를 의미하며, 송수신 데이터가 암호화되어 있음을 의미합니다. 속도는 더 느리지만 실제로 느껴질 정도는 아닙니다.

## HTTPS와 SSL

 HTTPS는 SSL 프로토콜에 기반하고 있습니다.

## SSL과 TLS

SSL(Secure Socket Layer)가 네스케이프에서 IETF의 관리로 변경되면서 TLS(Transport Layer Security)라는 이름으로 변경되었습니다. TLS 1.0은 SSL 3.0을 계승합니다.



## SSL에서 사용하는 암호화

SSL은 대칭키 암호화, 공개키 암호화를 혼용하여 사용합니다.

### 대칭키 암호 방식

**암호화와 복호화에 같은 키를 사용하는 방식**입니다. 이는 공개 키 암호에서 공개 키와 비밀 키를 별도로 가지는 것과 구별해야합니다.

### 단점

암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵습니다. 

따라서, 많은 암호화 통신에서 **비밀 키 암호를 사용하여 대칭 키 암호의 공통 키를 공유하고, 그 키를 기반으로 실제 통신을 암호화하는 구조를 사용**합니다.

### 공개키 암호 방식

두 개의 키를 사용합니다. A키로 암호화시 B키로만 복호화 가능하고, B키로 암호화시 A키로만 복호화 가능한 방식을 활용합니다. 

어떠한 암호화된 데이터가 공개 키 A로 복호화된다는 것은 비밀 키 B로 암호화되었다는 것이 보장됩니다. 즉, **공개 키가 데이터를 제공한 사람의 신원을 보장**해주는 것입니다. 이것을 **전자 서명**이라고 부릅니다.



## CA(Certificate Authority)

CA는 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있으며, 클라이언트가 접속한 서버가 신뢰할 수 있는지를 보장하는 역할을 수행합니다. SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA를 통해서 인증서를 구입해야 합니다.

> **사설 인증기관**
>
> 공인된 인증기관이 아닌 사설 CA의 인증서를 이용하면 브라우저 주소창에 경고문이 출력되는 것을 보실 수 있습니다.
>
> **CA 리스트**
>
> 브라우저는 내부적으로 CA의 리스트를 미리 파악하고 있습니다. 브라우저가 미리 파악하고 있는 CA의 리스트에 포함되어야만 공인된 CA가 될 수 있습니다. 즉, **공인 CA의 공개키를 브라우저는 이미 알고 있는 것**입니다.

## SSL 디지털 인증서

SSL 인증서는 클라이언트와 서버간의 통신을 제 3자인 인증기관(CA, Certificate Authority)이 보증해주는 전자화된 문서입니다.

### SSl 인증서의 내용

1. 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등등)
2. 서버 측 공개키(공개키의 내용, 공개키의 암호화 방법)

서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 합니다.

### SSL 인증서의 기능

1. 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장
2. SSL 통신에 사용할 공개키를 클라이언트에게 제공



## SSL 동작 흐름

SSL은 암호화된 데이터를 전송하기 위해 공개키와 대칭키를 혼합해서 사용합니다.

1. 실제 정보를 대칭키로 암호화(실제 데이터를 공개키로 암호화 및 복호화시 많은 컴퓨터 자원이 소모됨)
2. 같이 보낼 대칭키는 공개키 방식으로 암호화

통신을 할 때 내부적으로 3가지 단계가 존재합니다.

`악수 → 전송 → 세션종료`

### 악수(handshake)

이 과정에서 SSL 인증서를 주고 받습니다. 이 때, 공개키 암호화 방식이 사용됩니다. 데이터 전송단계에서도 공개키 암호화를 사용하면 많은 컴퓨터 자원을 소모하므로 전송단계에서는 대칭키 암호화만을 사용합니다.

1. 클라이언트가 서버에 접속

   - 클라이언트 측에서 생성한 데이터

   - 클라이언트가 지원하는 암호화 방식들

   - (세션 아이디)

     이미 SSL 핸드셰이킹을 한 이후에는 기존의 세션을 재활용합니다.

2. 서버가 클라이언트의 접속에 응답

   - 서버 측에서 생성한 랜덤 데이터
   - 서버가 선택한 클라이언트의 암호화 방식
   - 인증서

3. 클라이언트가 서버에서 전달한 인증서가 CA에 의해 발급된 것인지 확인

   - 클라이언트에 내장된(CA List에 있는) 공개 키를 이용해서 인증서를 복호화

4. 인증서가 확인되면, 클라이언트는 pre master secret이라는 키를 생성

   - 클라이언트의 랜덤 데이터와 서버의 랜덤 데이터를 조합하여 생성
   - pre master secret 키는 차후 세션 단계에서 대칭키로 사용되기 때문에 절대로 노출되어서는 안됨

5. 클라이언트는 pre master secret 키를 서버의 공개키(서버로부터 받은 인증서 안에 존재)로 암호화하여 전송

6. 서버는 수신한 암호 데이터를 개인 키로 복호화하여 pre master secret 키를 획득함

   - 클라이언트와 서버는 pre master secret 키를 이용하여 일련의 과정을 거쳐 master secret 키를 만듬
   - master secret 키는 session key를 생성하는 데, 이 session key를 이용하여 대칭키 암호화 방식으로 데이터를 송수신

7. 핸드쉐이크 단계의 종료를 서로에게 알림

### 세션종료

 SSL 통신이 끝났음을 서로에게 알려주고 통신에서 사용한 대칭키인 Session key를 폐기합니다.